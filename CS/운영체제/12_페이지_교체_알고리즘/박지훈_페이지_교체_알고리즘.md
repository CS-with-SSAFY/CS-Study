### 1. 페이지 교체?
- 필요한 페이지를 메모리에 올리다가 메모리가 결국 가득차게 된다. 또한, 올라와있던 페이지가 사용이 다 된 후에도 자리만 차지할 수 있다.
- 따라서 메모리가 가득차면 추가로 페이지를 가져오기 위해서는 안쓰는 페이지는 out 하고, 해당 공간에 현재 필요한 페이지를 in 시켜야 한다.
- 교체할 페이지는 수정되지 않은 페이지를 선택하자. 만약 수정된 페이지라면 메인 메모리에서 내보낼 때 하드디스크에서도 수정을 해야하므로 시간이 오래걸린다.

### 2. reference String?? (참조열)
그 프로세스가 언급하는 페이지들의 넘버. 
이를 사용해서 page replacement 알고리즘 분석.

### 3. 페이지 교체 알고리즘
1. FIFO 알고리즘
   - 메모리에 먼저 올라온 페이지를 먼저 내보내는 알고리즘
   - 가장 간단, 초기화 코드에서 적절
   - 페이지 부재율이 높음! (필요한 페이지가 현재 메모리에 없는 경우 발생하는 trap)

2. OPT 알고리즘
   - Optional, 앞으로 사용하지 않을 페이지를 가장 우선적으로 내보냄
   - 근데 뭘 사용하지 않을지 어떻게 알아? 기각

3. LRU 알고리즘
   - Least-Recently-Used, 최근에 사용하지 않은 페이지를 가장 먼저 내려보내는 알고리즘
   - OPT 는 미래 예측, LRU는 과거를 보고 판단.
   - 페이지 부재율은 OPT 보다는 높을 수 있지만, 실제로 사용가능한 페이지 교체 알고리즘.

   
문제) OPT 알고리즘을 활용하여 주어지는 조건에 맞게 풀어보자. 
    메모리 페이지 수를 최대 3개로 가정, 참조열이 다음과 같을 때, 페이지 부재율은?
    7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1
답) 총 9개의 부재 발생.
풀이) 현재 페이지에 주어지는 reference String 이 존재하지 않을 경우 페이지에 등록 == 페이지 부재.

나머지 FIFO와 LRU를 이용해서 부재율을 계산해보자. 
FIFO는 15개, LRU는 12개의 페이지 부재가 발생할 것이다.

### 4. 교체 방식
1) Global 교체 : 메모리 상의 모든 프로세스 페이지에 대해 교체
2) Local 교체 : 메모리 상의 자신의 프로세스 페이지에서만 교체하는 방식
