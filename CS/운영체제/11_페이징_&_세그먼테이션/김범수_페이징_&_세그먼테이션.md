# 페이징과 세그먼테이션

메모리: CPU가 직접 접근할 수 있는 기억 장치로, 프로세스가 실행되기 위해 프로그램 코드를 메인 메모리에 **적재**해야 한다.

이때 프로그램 용량이 메인 메모리보다 크다면??

## 초기 컴퓨터와 메모리 관리
초기 컴퓨터 시스템에서는 프로그램을 메모리에 올려 실행하는 방식이었다.

따라서 당시 **메모리 전체를 하나의 프로그램이 독점**하였고, 프로그램을 동시에 실행할 수도 없었다.

## 배치 처리 시스템
OS의 등장으로 여러 프로그램을 자동으로 실행할 수 있는 배치 처리 시스템이 개발됨.

이 시기부터 메모리 적재와 관리가 시작됐다.

**고정 분할**
- 메모리를 고정된 크기의 구역으로 나눠 구역마다 프로그램을 적재
- 동시 메모리 활용으로 멀티태스킹 가능(하지만, 제한적)
- 하지만, 크기에 비해 분할 구역에 따라 낭비 or 적재 불가 문제가 발생

## 동적 할당과 멀티프로그래밍
메모리 관리 기법이 한층 발전하며, **동적 할당**과 **멀티프로그래밍 도입**

**동적 할당**
- 고정된 크기 대신 필요한 만큼의 메모리 할당
- 단편화 문제: 메모리가 작은 조각으로 나뉘어 사용되지 않는 현상 발생

## 가상 메모리와 페이징 시스템

### 가상 메모리
물리 메모리와 논리 메모리 개념을 분리한 것이다. 메모리의 공간은 한정적이기 때문에, 더 많은 메모리 사용을 위해 가상 주소를 사용하는 것

**※ 가상 메모리가 필요한 이유**
- 물리 메모리의 한계
   - 용량에 한계, 프로그램 마다 스위칭 발생 시 성능 + 비용 문제
- 가상 메모리의 장점
   - 프로그램 용량이 실제 물리 메모리보다 커도 동작
   - 더 많은 프로그램 처리 가능 (CPU 이용률, 처리율 증가)

### 페이징 시스템
- 메모리를 일정한 크기의 페이지로 나누어 관리
- 페이지 단위로 메모리 할당 → 프로세스를 일정한 크기로 분할
- 외부 단편화가 생기지않음, 내부 단편화 발생 가능

### 세그먼테이션
- 메모리를 논리적인 단위로 나누어 관리하는 방식
- 가상 메모리를 서로 크기가 다른 논리적 단위로 분할
- 내부 단편화 문제 해소, 외부 단편화 문제 가능성

물리적 단위: 페이지
논리적 단위: 세그먼트